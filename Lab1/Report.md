# Laboratory Work 1: Introduction to Formal Languages and Finite Automata

### Course: Formal Languages & Finite Automata
### Author: Cretu Dumitru

----

## Overview

A formal language is a structured system of communication consisting of three essential components: the alphabet (a set of valid characters), the vocabulary (a set of valid words), and the grammar (a set of rules and constraints that govern valid sequences). Regular grammars are particularly important as a foundational concept, representing languages that can be generated systematically and recognized by finite automata. The relationship between grammars and finite automata is fundamental in formal language theory: any language generated by a regular grammar can be recognized by a finite automaton, and vice versa.

## Objectives

1. Understand the structure and components of formal languages, specifically regular grammars and their relationship to finite automata.

2. Implement a practical system that demonstrates the connection between grammars and automata:
   - Create a Grammar class that can represent formal grammar rules
   - Implement string generation functionality based on grammar rules
   - Implement conversion from a grammar to its equivalent finite automaton
   - Create a method to verify whether strings belong to the language

3. Apply theoretical concepts to a concrete programming solution using Python for variant 18:
   - VN = {S, A, B, C} (non-terminals)
   - VT = {a, b} (terminals)
   - Production rules: S → aA | aB, A → bS, B → aC, C → a | bS

## Implementation Description

### Grammar Class

The `Grammar` class serves as the representation of a formal grammar, encapsulating all necessary components defined by the 4-tuple (VN, VT, P, S). The class stores the non-terminals, terminals, production rules organized in a dictionary for efficient lookup, and the start symbol. This structure allows for systematic processing of production rules when generating strings.

```python
class Grammar:
    def __init__(self, VN, VT, P, S):
        self.VN = VN          # Non-terminal symbols
        self.VT = VT          # Terminal symbols (alphabet)
        self.P = P            # Production rules dictionary
        self.S = S            # Start symbol
```

### String Generation from Grammar

The `generateWords` method implements a derivation process that creates valid strings belonging to the language. The algorithm works by iteratively replacing non-terminal symbols with their corresponding production rules until only terminal symbols remain. The method uses random selection from available productions to ensure variety in generated strings.

```python
def generateWords(self, max):
    current = self.S
    steps = 0
    
    while steps < max:
        pos = -1
        symbol = None
        
        for i, ch in enumerate(current):
            if ch in self.VN:
                pos = i
                symbol = ch
                break
        
        if pos == -1:
            break
        
        production = random.choice(self.P[symbol])
        current = current[:pos] + production + current[pos+1:]
        steps += 1
    
    for ch in current:
        if ch in self.VN:
            return None
    return current
```

The algorithm maintains the current derivation string and searches for non-terminal symbols. Upon finding a non-terminal, it randomly selects a production rule and replaces that symbol. The process continues until either the maximum number of steps is reached or no non-terminals remain. If non-terminals persist after the maximum iterations, the function returns None to indicate an incomplete derivation.

### Finite Automaton Class

The `FiniteAutomaton` class represents a deterministic finite automaton with the standard 5-tuple components: Q (states), Σ (alphabet), δ (transition function), q₀ (initial state), and F (final/accepting states). This class provides the structure needed to verify whether input strings belong to the language recognized by the automaton.

```python
class FiniteAutomaton:
    def __init__(self, alphabet, transitions, states, start, final):
        self.alphabet = alphabet      # Input alphabet
        self.transitions = transitions # Transition function (delta)
        self.states = states          # Set of states
        self.start = start            # Initial state
        self.final = final            # Accepting states
```

### Grammar to Automaton Conversion

The conversion from a regular grammar to a finite automaton follows the standard construction method used in formal language theory. Each non-terminal symbol becomes a state in the automaton, the terminal symbols form the input alphabet, and production rules are converted to transitions. This conversion preserves the language: the set of strings accepted by the resulting automaton is identical to the set of strings generated by the original grammar.

## Variant 18 Specification

The implemented grammar follows variant 18 with the following definition:

- **VN** (Non-terminals): {S, A, B, C}
- **VT** (Terminals): {a, b}
- **Production Rules**:
  - S → aA
  - S → aB
  - A → bS
  - B → aC
  - C → a
  - C → bS
- **Start Symbol**: S

This grammar generates strings over the alphabet {a, b} with specific structural constraints. For example, any derivation must begin with S, and the rules ensure that certain sequences are possible while others are not.

## Testing and Verification

The implementation allows for generation of multiple valid strings from the grammar. Example outputs from the `generateWords` method include strings such as "a", "aba", "abaC", and others, all derivable from the production rules starting from the start symbol S. The finite automaton can then be used to verify whether arbitrary input strings belong to the language recognized by this grammar.

## Conclusions

This laboratory work demonstrates the practical implementation of fundamental formal language concepts. The separation between the Grammar and FiniteAutomaton classes reflects the theoretical relationship between these two models of computation. The Grammar class provides a generative approach (creating valid strings), while the FiniteAutomaton class provides a recognition approach (verifying string membership). Through this implementation, the equivalence between regular grammars and finite automata becomes tangible and testable.

The implementation is clean and modular, making it easy to extend with additional functionality such as input validation, epsilon-free grammar conversion, or DFA minimization. The Python language choice proved practical for implementing these concepts without unnecessary complexity in project setup or infrastructure.

## References

- Drumea, V., and Cojuhari, I. "Formal Languages and Finite Automata." Course Materials.
- Hopcroft, J. E., Motwani, R., and Ullman, J. D. "Introduction to Automata Theory, Languages, and Computation." Pearson, 2006.
- Dragon Book concepts on regular grammars and their relationship to finite automata.
