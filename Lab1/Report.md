# Laboratory Work 1: Introduction to Formal Languages and Finite Automata

### Course: Formal Languages & Finite Automata
### Author: Pancenco Ina, FAF-242

----

## Overview

A formal language is a structured system of communication consisting of three essential components: the alphabet (a set of valid characters), the vocabulary (a set of valid words), and the grammar (a set of rules and constraints that govern valid sequences). Regular grammars are particularly important as a foundational concept, representing languages that can be generated systematically and recognized by finite automata. The relationship between grammars and finite automata is fundamental in formal language theory: any language generated by a regular grammar can be recognized by a finite automaton, and vice versa.

## Objectives

1. Understand the structure and components of formal languages, specifically regular grammars and their relationship to finite automata.

2. Implement a practical system that demonstrates the connection between grammars and automata:
   - Create a Grammar class that can represent formal grammar rules
   - Implement string generation functionality based on grammar rules
   - Implement conversion from a grammar to its equivalent finite automaton
   - Create a method to verify whether strings belong to the language

3. Apply theoretical concepts to a concrete programming solution using Python for variant 18:
   - VN = {S, A, B, C} (non-terminals)
   - VT = {a, b} (terminals)
   - Production rules: S → aA | aB, A → bS, B → aC, C → a | bS

## Implementation Description

### Grammar Class

The `Grammar` class serves as the representation of a formal grammar, encapsulating all necessary components defined by the 4-tuple (VN, VT, P, S). The class stores the non-terminals, terminals, production rules organized in a dictionary for efficient lookup, and the start symbol. This structure allows for systematic processing of production rules when generating strings.

```python
class Grammar:
    def __init__(self, VN, VT, P, S):
        self.VN = VN          # Non-terminal symbols
        self.VT = VT          # Terminal symbols (alphabet)
        self.P = P            # Production rules dictionary
        self.S = S            # Start symbol
```

### String Generation from Grammar

The `generateWords` method implements a derivation process that creates valid strings belonging to the language. The algorithm works by iteratively replacing non-terminal symbols with their corresponding production rules until only terminal symbols remain. The method uses random selection from available productions to ensure variety in generated strings.

```python
def generateWords(self, max):
    current = self.S
    steps = 0
    
    while steps < max_steps:
        pos = -1
        symbol = None
        
        for i, ch in enumerate(current):
            if ch in self.VN:
                pos = i
                symbol = ch
                break
        
        if pos == -1:
            break
        
        production = random.choice(self.P[symbol])
        current = current[:pos] + production + current[pos+1:]
        steps += 1
    
    return current
```

The algorithm maintains the current derivation string and searches for non-terminal symbols. Upon finding a non-terminal, it randomly selects a production rule and replaces that symbol. The process continues until either the maximum number of steps is reached or no non-terminals remain. The method now returns the derived string at any stage, which may contain both terminal and non-terminal symbols depending on the number of derivation steps performed. This allows for greater flexibility in exploring the language generation process, including intermediate derivations that contain non-terminals.

### Finite Automaton Class

The `FiniteAutomaton` class represents a deterministic finite automaton with the standard 5-tuple components: Q (states), Σ (alphabet), δ (transition function), q₀ (initial state), and F (final/accepting states). This class provides the structure needed to verify whether input strings belong to the language recognized by the automaton.

```python
class FiniteAutomaton:
    def __init__(self, alphabet, transitions, states, start, final):
        self.alphabet = alphabet      # Input alphabet
        self.transitions = transitions # Transition function (delta)
        self.states = states          # Set of states
        self.start = start            # Initial state
        self.final = final            # Accepting states
```

### Grammar to Automaton Conversion

The conversion from a regular grammar to a finite automaton follows the standard construction method used in formal language theory. Each non-terminal symbol becomes a state in the automaton, the terminal symbols form the input alphabet, and production rules are converted to transitions. This conversion preserves the language: the set of strings accepted by the resulting automaton is identical to the set of strings generated by the original grammar.

## Variant 18 Specification

The implemented grammar follows variant 18 with the following definition:

- **VN** (Non-terminals): {S, A, B, C}
- **VT** (Terminals): {a, b}
- **Production Rules**:
  - S → aA
  - S → aB
  - A → bS
  - B → aC
  - C → a
  - C → bS
- **Start Symbol**: S

This grammar generates strings over the alphabet {a, b} with specific structural constraints. For example, any derivation must begin with S, and the rules ensure that certain sequences are possible while others are not.

## Testing and Verification

The implementation allows for generation of multiple valid strings from the grammar. The `generateWords` method can generate strings at various stages of derivation:

- **Fully terminal strings**: When using larger `max_steps` values (e.g., 20), the algorithm typically produces strings containing only terminal symbols {a, b}. Examples: "abaaa", "ababaaa", "aabaaa".

- **Strings with non-terminals**: When using smaller `max_steps` values, the algorithm returns intermediate derivations that may contain both non-terminal symbols {S, A, B, C} and terminal symbols. This provides flexibility in exploring the derivation process at different levels.

Example execution output:
```
Generated strings:
aabaabaaa
abaaa
aabaaa
abaaa
ababababaabaaa

Testing generated strings:
aabaabaaa -> True
abaaa -> True
aabaaa -> True
abaaa -> True
ababababaabaaa -> True
```

The finite automaton can verify whether arbitrary strings belong to the language recognized by this grammar using the `stringBelongToLanguage()` method. All generated strings in the above example are accepted by the automaton, confirming the correctness of both the grammar and its equivalent finite automaton representation.

## Conclusions

This laboratory work demonstrates the practical implementation of fundamental formal language concepts. The separation between the Grammar and FiniteAutomaton classes reflects the theoretical relationship between these two models of computation. The Grammar class provides a generative approach (creating valid strings), while the FiniteAutomaton class provides a recognition approach (verifying string membership). Through this implementation, the equivalence between regular grammars and finite automata becomes tangible and testable.

The implementation is clean and modular, making it easy to extend with additional functionality such as input validation, epsilon-free grammar conversion, or DFA minimization.


